@page "/recipes"
@using MudBlazor
@using RecettesIndex.Models
@using RecettesIndex.Services
@using RecettesIndex.Services.Abstractions
@inject AuthService AuthService
@inject IDialogService DialogService
@inject IRecipeService RecipeService
@inject ISnackbar Snackbar

<PageTitle>Recettes</PageTitle>

<MudPaper Class="pa-4">
    <MudText Typo="Typo.h5">Recettes</MudText>
    <MudBreadcrumbs Items="breadcrumbs" Class="mb-4" />
    
    <!-- Quick Filter Buttons -->
    <MudStack Row Wrap="Wrap.Wrap" Spacing="2" Class="mb-3">
        <MudChip T="string" Color="@(showAllRecipes ? Color.Primary : Color.Default)" 
                 OnClick="ShowAll" 
                 Label="true">
            Toutes (@totalCount)
        </MudChip>
        <MudChip T="string" Color="@(quickFilterRating == 5 ? Color.Warning : Color.Default)" 
                 OnClick="() => ApplyQuickFilter(5)" 
                 Label="true" 
                 Icon="@Icons.Material.Filled.Star">
            5 Étoiles (@fiveStarCount)
        </MudChip>
        <MudChip T="string" Color="@(quickFilterRating == 4 ? Color.Info : Color.Default)" 
                 OnClick="() => ApplyQuickFilter(4)" 
                 Label="true">
            4+ Étoiles (@fourPlusStarCount)
        </MudChip>
        <MudChip T="string" Color="@(quickFilterUnrated ? Color.Secondary : Color.Default)" 
                 OnClick="ShowUnrated" 
                 Label="true"
                 Icon="@Icons.Material.Filled.HelpOutline">
            Non évaluées (@unratedCount)
        </MudChip>
        @if (!string.IsNullOrWhiteSpace(searchTerm) || ratingFilter != null || bookFilter != null || authorFilter != null)
        {
            <MudChip T="string" Color="Color.Error" 
                     OnClick="ClearAllFilters" 
                     Label="true"
                     Icon="@Icons.Material.Filled.Clear">
                Réinitialiser les filtres
            </MudChip>
        }
    </MudStack>
    
    <!-- Advanced Search and Filters -->
    <MudStack Row AlignItems="AlignItems.Center" Spacing="2" Class="mb-2">
        <MudTextField T="string" 
                      Value="@searchTerm" 
                      ValueChanged="OnSearchChanged" 
                      Placeholder="Rechercher des recettes..." 
                      Adornment="Adornment.Start" 
                      AdornmentIcon="@Icons.Material.Filled.Search"
                      Clearable="true"
                      Immediate="false"
                      DebounceInterval="300" />
        <MudSelect T="string" 
                   Value="@ratingFilter" 
                   ValueChanged="OnRatingChanged" 
                   Clearable="true" 
                   Dense="true" 
                   Label="Évaluation" 
                   Class="min-w-200">
            <MudSelectItem T="string" Value='@("all")'>Toutes</MudSelectItem>
            <MudSelectItem T="string" Value='@("1")'>⭐ 1</MudSelectItem>
            <MudSelectItem T="string" Value='@("2")'>⭐ 2</MudSelectItem>
            <MudSelectItem T="string" Value='@("3")'>⭐ 3</MudSelectItem>
            <MudSelectItem T="string" Value='@("4")'>⭐ 4</MudSelectItem>
            <MudSelectItem T="string" Value='@("5")'>⭐ 5</MudSelectItem>
        </MudSelect>
        <MudSelect T="string" 
                   Value="@bookFilter" 
                   ValueChanged="OnBookChanged" 
                   Clearable="true" 
                   Dense="true" 
                   Label="Livre" 
                   Class="min-w-200">
            <MudSelectItem T="string" Value='@("all")'>Tous (@books.Count)</MudSelectItem>
            @foreach (var b in books)
            {
                var recipeCount = GetRecipeCountForBook(b.Id);
                <MudSelectItem T="string" Value="@b.Id.ToString()">@b.Name (@recipeCount)</MudSelectItem>
            }
        </MudSelect>
        <MudSelect T="string" 
                   Value="@authorFilter" 
                   ValueChanged="OnAuthorChanged" 
                   Clearable="true" 
                   Dense="true" 
                   Label="Auteur" 
                   Class="min-w-200">
            <MudSelectItem T="string" Value='@("all")'>Tous (@authors.Count)</MudSelectItem>
            @foreach (var a in authors)
            {
                var recipeCount = GetRecipeCountForAuthor(a.Id);
                <MudSelectItem T="string" Value="@a.Id.ToString()">@a.FullName (@recipeCount)</MudSelectItem>
            }
        </MudSelect>
    </MudStack>

    <!-- Active Filters Display -->
    @if (HasActiveFilters())
    {
        <MudPaper Elevation="0" Class="pa-2 mb-2" Style="background-color: #f5f5f5;">
            <MudStack Row Spacing="1" AlignItems="AlignItems.Center">
                <MudText Typo="Typo.body2" Style="font-weight: 500;">Filtres actifs:</MudText>
                @if (!string.IsNullOrWhiteSpace(searchTerm))
                {
                    <MudChip T="string" Size="Size.Small" OnClose="() => ClearSearch()">
                        Recherche: @searchTerm
                    </MudChip>
                }
                @if (ratingFilter != null && ratingFilter != "all")
                {
                    <MudChip T="string" Size="Size.Small" OnClose="() => ClearRating()">
                        Note: @ratingFilter ⭐
                    </MudChip>
                }
                @if (bookFilter != null && bookFilter != "all")
                {
                    var book = books.FirstOrDefault(b => b.Id.ToString() == bookFilter);
                    if (book != null)
                    {
                        <MudChip T="string" Size="Size.Small" OnClose="() => ClearBook()">
                            Livre: @book.Name
                        </MudChip>
                    }
                }
                @if (authorFilter != null && authorFilter != "all")
                {
                    var author = authors.FirstOrDefault(a => a.Id.ToString() == authorFilter);
                    if (author != null)
                    {
                        <MudChip T="string" Size="Size.Small" OnClose="() => ClearAuthor()">
                            Auteur: @author.FullName
                        </MudChip>
                    }
                }
            </MudStack>
        </MudPaper>
    }

    <MudTable T="Recipe" ServerData="LoadServerData" Hover="true" Elevation="1" Dense="true" RowsPerPage="20" @ref="table">
        <PagerContent>
            <MudTablePager InfoFormat="Affichage {first_item}-{last_item} sur {all_items}"
                           RowsPerPageString="Lignes par page:"
                           PageSizeOptions="[10, 20, 50]" />
        </PagerContent>
        <HeaderContent>
            <MudTh><MudTableSortLabel T="Recipe" SortLabel="name">Nom</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel T="Recipe" SortLabel="rating">Évaluation</MudTableSortLabel></MudTh>
            <MudTh><MudTableSortLabel T="Recipe" SortLabel="created_at">Créée le</MudTableSortLabel></MudTh>
            <MudTh>Notes</MudTh>
            <MudTh>Livre</MudTh>
            @if (AuthService.IsAuthenticated)
            {
                <MudTh>Actions</MudTh>
            }
        </HeaderContent>
        <RowTemplate>
            <MudTd DataLabel="Nom">
                <MudLink Href="@($"/recipes/{context.Id}")" Style="cursor:pointer">@context.Name</MudLink>
            </MudTd>
            <MudTd DataLabel="Évaluation">
                <PizzaRating Value="@context.Rating" />
            </MudTd>
            <MudTd DataLabel="Créée le">@context.CreationDate.ToShortDateString()</MudTd>
            <MudTd DataLabel="Notes">
                @if (!string.IsNullOrWhiteSpace(context.Notes))
                {
                    var preview = context.Notes.Length > 50 ? context.Notes.Substring(0, 50) + "..." : context.Notes;
                    <MudTooltip Text="@context.Notes">
                        <MudText Typo="Typo.body2">@preview</MudText>
                    </MudTooltip>
                }
            </MudTd>
            <MudTd DataLabel="Livre">
                @if (context.BookId != null)
                {
                    var book = books.FirstOrDefault(b => b.Id == context.BookId);
                    if (book != null)
                    {
                        <MudLink Href="@($"/books/{book.Id}")" Style="cursor:pointer">@book.Name</MudLink>
                    }
                }
            </MudTd>
            @if (AuthService.IsAuthenticated)
            {
                <MudTd>
                    <MudButton Variant="Variant.Text" Color="Color.Primary" OnClick="() => ShowEditDialog(context)">Modifier</MudButton>
                    <MudButton Variant="Variant.Text" Color="Color.Error" OnClick="() => DeleteRecipe(context)">Supprimer</MudButton>
                </MudTd>
            }
        </RowTemplate>
    </MudTable>
    @if (AuthService.IsAuthenticated)
    {
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Class="mt-2" OnClick="ShowAddDialog">Ajouter une recette</MudButton>
    }
</MudPaper>

@code {
    private MudTable<Recipe>? table;
    private List<Book> books = [];
    private List<Author> authors = [];
    private List<BreadcrumbItem> breadcrumbs =
    [
        new BreadcrumbItem("Accueil", href: "/"),
        new BreadcrumbItem("Recettes", href: "/recipes", disabled: true)
    ];
    private string searchTerm = string.Empty;
    private string? ratingFilter;
    private string? bookFilter;
    private string? authorFilter;
    
    // Quick filter state
    private bool showAllRecipes = true;
    private int? quickFilterRating = null;
    private bool quickFilterUnrated = false;
    
    // Filter counts
    private int totalCount = 0;
    private int fiveStarCount = 0;
    private int fourPlusStarCount = 0;
    private int unratedCount = 0;
    private Dictionary<int, int> bookRecipeCounts = new();
    private Dictionary<int, int> authorRecipeCounts = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadRecipes();
        await LoadFilterCounts();
    }

    private async Task LoadRecipes()
    {
        books = (await RecipeService.GetBooksAsync())?.ToList() ?? new();
        authors = (await RecipeService.GetAuthorsAsync())?.ToList() ?? new();
        await Reload();
    }

    private async Task LoadFilterCounts()
    {
        // Load all recipes to calculate counts
        var result = await RecipeService.SearchAsync(null, null, null, null, 1, 10000);
        if (result.IsSuccess)
        {
            var allRecipes = result.Value.Items;
            totalCount = allRecipes.Count;
            fiveStarCount = allRecipes.Count(r => r.Rating == 5);
            fourPlusStarCount = allRecipes.Count(r => r.Rating >= 4);
            unratedCount = allRecipes.Count(r => r.Rating == 0 || r.Rating < 1);
            
            // Calculate book counts
            bookRecipeCounts = allRecipes
                .Where(r => r.BookId.HasValue)
                .GroupBy(r => r.BookId!.Value)
                .ToDictionary(g => g.Key, g => g.Count());
            
            // Calculate author counts (through books)
            authorRecipeCounts = new Dictionary<int, int>();
            foreach (var author in authors)
            {
                var authorBookIds = books.Where(b => b.Authors.Any(a => a.Id == author.Id)).Select(b => b.Id).ToHashSet();
                var count = allRecipes.Count(r => r.BookId.HasValue && authorBookIds.Contains(r.BookId.Value));
                authorRecipeCounts[author.Id] = count;
            }
        }
    }

    private int GetRecipeCountForBook(int bookId) => bookRecipeCounts.GetValueOrDefault(bookId, 0);
    private int GetRecipeCountForAuthor(int authorId) => authorRecipeCounts.GetValueOrDefault(authorId, 0);

    private bool HasActiveFilters()
    {
        return !string.IsNullOrWhiteSpace(searchTerm) 
            || (ratingFilter != null && ratingFilter != "all") 
            || (bookFilter != null && bookFilter != "all") 
            || (authorFilter != null && authorFilter != "all");
    }

    private async Task ShowAll()
    {
        showAllRecipes = true;
        quickFilterRating = null;
        quickFilterUnrated = false;
        ratingFilter = null;
        await Reload();
    }

    private async Task ApplyQuickFilter(int rating)
    {
        showAllRecipes = false;
        quickFilterRating = rating;
        quickFilterUnrated = false;
        ratingFilter = rating >= 4 ? null : rating.ToString(); // For 4+, we'll filter in code
        await Reload();
    }

    private async Task ShowUnrated()
    {
        showAllRecipes = false;
        quickFilterRating = null;
        quickFilterUnrated = true;
        ratingFilter = null;
        await Reload();
    }

    private async Task ClearAllFilters()
    {
        searchTerm = string.Empty;
        ratingFilter = null;
        bookFilter = null;
        authorFilter = null;
        showAllRecipes = true;
        quickFilterRating = null;
        quickFilterUnrated = false;
        await Reload();
    }

    private async Task ClearSearch()
    {
        searchTerm = string.Empty;
        await Reload();
    }

    private async Task ClearRating()
    {
        ratingFilter = null;
        quickFilterRating = null;
        quickFilterUnrated = false;
        showAllRecipes = true;
        await Reload();
    }

    private async Task ClearBook()
    {
        bookFilter = null;
        await Reload();
    }

    private async Task ClearAuthor()
    {
        authorFilter = null;
        await Reload();
    }

    private async Task ShowAddDialog()
    {
        var dialog = await DialogService.ShowAsync<AddRecipeDialog>("Ajouter une recette");
        var result = await dialog.Result;
        if (result is not null && !result.Canceled)
        {
            await LoadRecipes();
            await LoadFilterCounts();
        }
    }

    private async Task ShowEditDialog(Recipe recipeToEdit)
    {
        var parameters = new MudBlazor.DialogParameters { ["RecipeToEdit"] = recipeToEdit };
        var dialog = await DialogService.ShowAsync<EditRecipeDialog>("Modifier la recette", parameters);
        var result = await dialog.Result;
        if (result is not null && !result.Canceled)
        {
            await LoadRecipes();
            await LoadFilterCounts();
        }
    }

    private async Task DeleteRecipe(Recipe recipeToDelete)
    {
        try
        {
            bool? confirm = await DialogService.ShowMessageBox(
                "Confirmer la suppression",
                $"Êtes-vous sûr de vouloir supprimer la recette '{recipeToDelete.Name}' ? Cette action est irréversible.",
                yesText: "Supprimer",
                cancelText: "Annuler");

            if (confirm != true)
            {
                return;
            }

            var res = await RecipeService.DeleteAsync(recipeToDelete.Id);
            if (res.IsSuccess)
            {
                Snackbar.Add($"La recette '{recipeToDelete.Name}' a été supprimée avec succès.", Severity.Success);
                await Reload();
                await LoadFilterCounts();
            }
            else
            {
                Snackbar.Add(res.ErrorMessage ?? "Une erreur s'est produite lors de la suppression de la recette.", Severity.Error);
            }
        }
        catch (Exception)
        {
            Snackbar.Add("Une erreur s'est produite lors de la suppression de la recette. Veuillez réessayer.", Severity.Error);
        }
    }

    private async Task<TableData<Recipe>> LoadServerData(TableState state, CancellationToken token)
    {
        var page = state.Page + 1;
        var pageSize = state.PageSize;
        
        // Apply quick filters
        int? rating = null;
        if (quickFilterUnrated)
        {
            // We'll handle unrated filter in post-processing
        }
        else if (quickFilterRating.HasValue)
        {
            if (quickFilterRating.Value == 4)
            {
                // For 4+, we'll filter in post-processing
            }
            else
            {
                // For exact rating (5, 3, 2, 1), pass to search
                rating = quickFilterRating.Value;
            }
        }
        else if (ratingFilter != "all" && !string.IsNullOrWhiteSpace(ratingFilter))
        {
            rating = int.TryParse(ratingFilter, out var r) ? r : null;
        }
        
        int? bookId = (bookFilter == "all" || string.IsNullOrWhiteSpace(bookFilter)) ? null : (int.TryParse(bookFilter, out var b) ? b : null);
        int? authorId = (authorFilter == "all" || string.IsNullOrWhiteSpace(authorFilter)) ? null : (int.TryParse(authorFilter, out var a) ? a : null);
        
        var sortLabel = state.SortLabel;
        var sortDescending = state.SortDirection == SortDirection.Descending;
        
        var result = await RecipeService.SearchAsync(searchTerm, rating, bookId, authorId, page, pageSize, sortLabel, sortDescending);
        if (!result.IsSuccess)
            return new TableData<Recipe> { Items = Array.Empty<Recipe>(), TotalItems = 0 };
        
        var items = result.Value.Items;
        var total = result.Value.Total;
        
        // Post-process for special filters
        if (quickFilterUnrated)
        {
            items = items.Where(r => r.Rating == 0 || r.Rating < 1).ToList();
            total = items.Count;
        }
        else if (quickFilterRating == 4)
        {
            // Only filter 4+ stars in post-processing
            items = items.Where(r => r.Rating >= 4).ToList();
            total = items.Count;
        }
        
        return new TableData<Recipe> { Items = items, TotalItems = total };
    }

    private async Task Reload()
    {
        if (table is not null)
        {
            await table.ReloadServerData();
        }
    }

    private async Task OnRatingChanged(string? value)
    {
        ratingFilter = value;
        showAllRecipes = false;
        quickFilterRating = null;
        quickFilterUnrated = false;
        await Reload();
    }

    private async Task OnBookChanged(string? value)
    {
        bookFilter = value;
        await Reload();
    }

    private async Task OnAuthorChanged(string? value)
    {
        authorFilter = value;
        await Reload();
    }

    private async Task OnSearchChanged(string value)
    {
        searchTerm = value;
        await Reload();
    }
}
